数据驱动视图

数据 驱动 试图 => 数据改变 -> 驱动程序 -> 视图更新（数据更新后通知驱动程序，由驱动程序更新试图）

1.可检测对象
对象 => Object => Object.defineProperty() => getter/setter
数组 => Array => 重写Array的部分原型方法（push、pop、shift、unshift、splice、sort、reverse）

2.依赖收集
2.1.什么是依赖收集？
	1⃣数据发生变化，就去通知视图更新就好了。但是，总不能一个数据变化了，把整个视图全部更新一遍，这显然是不合理的。
	2⃣如果我们知道谁用到了这个数据就更新谁岂不是更合理一些，换个更优雅的说法：把“谁用到了这个数据”称为“谁依赖了这个数据”，那么我们可以为每个数据建立一个依赖数组（一个数据可能会在多处使用），谁依赖了这个数据就把谁放到依赖数组中，那么当这个数据发生变化的时候，就把这个数据对应的依赖数据中的每个依赖都通知一遍：“数据变化了”。

2.2.何时进行依赖收集？何时通知依赖更新？
	1⃣谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，就是谁获取了这个数据，而在可观测对象在获取数据会触发getter访问器属性。同样，这个数据变化时会触发setter访问器属性。
	2⃣结论：在getter中收集依赖，在setter中通知依赖更新。

2.3.依赖收集到哪里
	1⃣需要为每个数据建立一个依赖数组，谁依赖这个数据就把谁放入这个依赖数组中；
	2⃣如果单单用一个数组来存放依赖的话，功能似乎有点欠缺且代码过于耦合，应该将依赖数组的功能扩展一下，更好的做法是为每一个数据都建立一个依赖收集器，把这个数据所有的依赖都管理起来。

3.依赖到底是谁
	谁用了这个数据谁就是依赖？ => Watcher
	1⃣谁用到了数据，谁就是依赖，就为谁创建一个Watcher实例，在创建Watcher的过程中会将自己添加到这个数据对应的依赖管理器中，这个Watcher实例就代表这个依赖，当数据变化时就通知Watcher实例，由Watcher实例再去通知真正的依赖进行对应的更新。

